"use strict";
const Api = require('binance');
const logger = require('winston');
const _ = require('lodash');
const Big = require('big.js');
const Errors = require('../../errors');
const AbstractExchangeClass = require('../../abstract-exchange');
const PromiseHelper = require('../../promise-helper');
const SubscriptionManagerClass = require('./subscription-manager');

const exchangeType = 'binance';

// maximum number of orders we can request when calling allOrders
const ALL_ORDERS_LIMIT_PER_ITER = 500;

// maximum number of entries when retrieving own trades
const OWN_TRADES_LIMIT_PER_ITER = 500;

// default limit when retrieving trades
const TRADES_DEFAULT_LIMIT = 500;

// default limit when retrieving order book
const ORDER_BOOK_DEFAULT_LIMIT = 100;

// list of possible limits for order book
const supportedOrderBooksLimits = [5, 10, 20, 50, 100, 500, 1000]
// {depth:weight} only for depth with a weight > 1
const orderBooksWeights = {
    500:5,
    1000:10
}

// list of possible interval for klines
const supportedKlinesIntervals = [
  '1m', '3m', '5m', '15m', '30m',
  '1h', '2h', '4h', '6h', '8h', '12h',
  '1d', '3d',
  '1w',
  '1M'
]
const defaultKlinesInterval = '5m';

// list of all possible features (should be enabled by default if supported by class)
const supportedFeatures = {
    'pairs':{enabled:true},
    'tickers':{enabled:true, withoutPair:false}, 'wsTickers':{enabled:true},
    'orderBooks':{enabled:true}, 'wsOrderBooks':{enabled:true},
    'trades':{enabled:true}, 'wsTrades':{enabled:true},
    'klines':{enabled:true,intervals:supportedKlinesIntervals,defaultInterval:defaultKlinesInterval}, 'wsKlines':{enabled:true,intervals:supportedKlinesIntervals,defaultInterval:defaultKlinesInterval},
    'orders':{enabled:true, withoutPair:false},
    'openOrders':{enabled:true, withoutPair:false},
    'closedOrders':{enabled:true, withoutPair:false, completeHistory:true},
    'balances':{enabled:true, withoutCurrency:true}
};

class Exchange extends AbstractExchangeClass
{

/**
 * Constructor
 *
 * @param {string} exchangeId exchange identifier (ex: binance)
 * @param {string} exchangeName exchange name (ex: Binance)
 * @param {object} config full config object
 */
constructor(exchangeId, exchangeName, config)
{
    super(exchangeId, exchangeType, exchangeName, supportedFeatures, config);
    let opt = {
        key:config.exchanges[exchangeId].key,
        secret:config.exchanges[exchangeId].secret,
        recvWindow:config.exchanges[exchangeId].recvWindow,
        timeout:15000,
        disableBeautification:true
    };
    this._restClient = new Api.BinanceRest(opt);
    // limiters
    this._limiterGlobal = this._getRateLimiter(config.exchanges[exchangeId].throttle.global.maxRequestsPerSecond);
    let weightedRate;
    // limiter for methods with a weight of 5
    weightedRate = parseInt(config.exchanges[exchangeId].throttle.global.maxRequestsPerSecond / 5);
    if (0 == weightedRate)
    {
        weightedRate = 1;
    }
    this._limiterWeight5 = this._getRateLimiter(weightedRate);
    this._limiterWeight5.chain(this._limiterGlobal);
    // limiter for methods with a weight of 10
    weightedRate = parseInt(config.exchanges[exchangeId].throttle.global.maxRequestsPerSecond / 10);
    if (0 == weightedRate)
    {
        weightedRate = 1;
    }
    this._limiterWeight10 = this._getRateLimiter(weightedRate);
    this._limiterWeight10.chain(this._limiterGlobal);

    let subscriptionManager = new SubscriptionManagerClass(this, config);
    this._setSubscriptionManager(subscriptionManager);
}

/**
 * Indicates whether or not error was generated by Binance
 *
 * @param {object} e error generated
 * @return {boolean}
 */
_isBinanceError(e)
{
    return undefined !== e.code && undefined !== e.msg;
}

/**
 * Indicates whether or not error is an authentication error
 *
 * @param {object} e error generated
 * @return {boolean}
 */
_isInvalidAuthError(e)
{
    switch (e.code)
    {
        // BAD_API_ID
        case -2008:
        // BAD_API_KEY_FMT
        case -2014:
        // REJECTED_MBX_KEY
        case -2015:
            return true;
    }
    return false;
}

/**
 * Indicates whether or not error is for an invalid request
 *
 * @param {object} e error generated
 * @return {boolean}
 */
_isInvalidRequestError(e)
{
    // INVALID_MESSAGE
    return -1013 == e.code;
}

/**
 * Convert pair from exchange format YX to custom format X-Y
 *
 * @param {string} pair pair in exchange format (YX)
 * @return {string} pair in custom format (X-Y)
 */
_toCustomPair(pair)
{
    let baseCurrency = pair.substr(-3);
    let currency;
    if ('SDT' == baseCurrency)
    {
        baseCurrency = 'USDT';
        currency = pair.substr(0, pair.length - 4);
    }
    else
    {
        currency = pair.substr(0, pair.length - 3);
    }
    return baseCurrency + '-' + currency;
}

/**
 * Convert pair from custom format X-Y to exchange format YX
 * @param {string} pair pair in custom format (X-Y)
 * @return {string} pair in exchange format (YX)
 */
_toExchangePair(pair)
{
    let arr = pair.split('-');
    return arr[1] + arr[0];
}

/**
 * Returns all active pairs
 *
 * @return {Promise}
 */
 /*
 Raw output example for https://api.binance.com/api/v1/exchangeInfo

 {
     "serverTime":1523271018810,
     "exchangeFilters":[

     ],
     "symbols":[
         {
             "filters":[
                 {
                     "filterType":"PRICE_FILTER",
                     "minPrice":"0.00000100",
                     "maxPrice":"100000.00000000",
                     "tickSize":"0.00000100"
                 },
                 {
                     "filterType":"LOT_SIZE",
                     "maxQty":"100000.00000000",
                     "stepSize":"0.00100000",
                     "minQty":"0.00100000"
                 },
                 {
                     "minNotional":"0.00100000",
                     "filterType":"MIN_NOTIONAL"
                 }
             ],
             "orderTypes":[
                 "LIMIT",
                 "LIMIT_MAKER",
                 "MARKET",
                 "STOP_LOSS_LIMIT",
                 "TAKE_PROFIT_LIMIT"
             ],
             "baseAsset":"ETH",
             "quotePrecision":8,
             "symbol":"ETHBTC",
             "baseAssetPrecision":8,
             "icebergAllowed":true,
             "quoteAsset":"BTC",
             "status":"TRADING"
         },
         {
             "status":"TRADING",
             "quoteAsset":"BTC",
             "symbol":"LTCBTC",
             "baseAssetPrecision":8,
             "quotePrecision":8,
             "icebergAllowed":true,
             "baseAsset":"LTC",
             "orderTypes":[
                 "LIMIT",
                 "LIMIT_MAKER",
                 "MARKET",
                 "STOP_LOSS_LIMIT",
                 "TAKE_PROFIT_LIMIT"
             ],
             "filters":[
                 {
                     "filterType":"PRICE_FILTER",
                     "minPrice":"0.00000100",
                     "maxPrice":"100000.00000000",
                     "tickSize":"0.00000100"
                 },
                 {
                     "maxQty":"100000.00000000",
                     "stepSize":"0.01000000",
                     "minQty":"0.01000000",
                     "filterType":"LOT_SIZE"
                 },
                 {
                     "filterType":"MIN_NOTIONAL",
                     "minNotional":"0.00100000"
                 }
             ]
         }
     ]
 }
 */
async _getPairs()
{
    let self = this;
    return this._limiterGlobal.schedule(async function(){
        let data;
        try
        {
            data = await self._restClient.exchangeInfo();
        }
        catch (e)
        {
            if (self._isBinanceError(e))
            {
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
            }
            throw e;
        }
        let list = {};
        // count active pairs
        let activePairs = 0;
        _.forEach(data.symbols, (entry) => {
            // ignore if status != 'TRADING'
            if ('TRADING' != entry.status)
            {
                return;
            }
            // ignore dummy entry
            if ('123456' == entry.symbol)
            {
                return;
            }
            ++activePairs;
            let baseCurrency = entry.quoteAsset;
            switch (baseCurrency)
            {
                // only keep BTC, ETH, USD & BNC as base currency
                case 'BTC':
                case 'ETH':
                case 'USDT':
                case 'BNB':
                    break;
                default:
                    return;
            }
            let currency = entry.baseAsset;
            let pair = baseCurrency + '-' + currency;
            let filters = {};
            for (var i = 0; i < entry.filters.length; ++i)
            {
                filters[entry.filters[i].filterType] = entry.filters[i];
            }
            // add precision & limits
            let obj = {
                pair:pair,
                baseCurrency: baseCurrency,
                currency: currency,
                limits:{
                    rate:{
                       min:parseFloat(filters['PRICE_FILTER'].minPrice),
                       max:parseFloat(filters['PRICE_FILTER'].maxPrice),
                       step:parseFloat(filters['PRICE_FILTER'].tickSize),
                       precision:self._stepToPrecision(filters['PRICE_FILTER'].tickSize)
                    },
                    quantity:{
                        min:parseFloat(filters['LOT_SIZE'].minQty),
                        max:parseFloat(filters['LOT_SIZE'].maxQty),
                        step:parseFloat(filters['LOT_SIZE'].stepSize),
                        precision:self._stepToPrecision(filters['LOT_SIZE'].stepSize)
                    },
                    price:{
                        min:parseFloat(filters['MIN_NOTIONAL'].minNotional),
                        max:null
                    }
                }
            }
            list[pair] = obj;
        });
        return list;
    });
}

/**
 * Returns ticker for a single pair
 *
 * @param {string} pair pair to retrieve ticker for
 * @return {Promise}
 */
 /*
 Raw output example for https://api.binance.com/api/v1/ticker/24hr

 {
     "symbol":"NEOUSDT",
     "priceChange":"3.99100000",
     "priceChangePercent":"8.450",
     "weightedAvgPrice":"53.00688702",
     "prevClosePrice":"47.22900000",
     "lastPrice":"51.22000000",
     "lastQty":"1.00000000",
     "bidPrice":"51.09800000",
     "bidQty":"2.93000000",
     "askPrice":"51.18300000",
     "askQty":"0.78000000",
     "openPrice":"47.22900000",
     "highPrice":"57.37500000",
     "lowPrice":"46.90500000",
     "volume":"707420.68300000",
     "quoteVolume":"37498168.21922800",
     "openTime":1523184095845,
     "closeTime":1523270495845,
     "firstId":7142459,
     "lastId":7214976,
     "count":72518
 }
 */
async _getTicker(pair)
{
    let symbol = this._toExchangePair(pair);
    let self = this;
    return this._limiterGlobal.schedule(async function(){
        let data;
        try
        {
            data = await self._restClient.ticker24hr({symbol:symbol});
        }
        catch (e)
        {
            if (self._isBinanceError(e))
            {
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
            }
            throw e;
        }
        let ticker = {
            pair:pair,
            last: parseFloat(data.lastPrice),
            priceChangePercent: parseFloat(data.priceChangePercent),
            sell: parseFloat(data.askPrice),
            buy: parseFloat(data.bidPrice),
            high: parseFloat(data.highPrice),
            low: parseFloat(data.lowPrice),
            volume: parseFloat(data.volume),
            timestamp: parseFloat(data.closeTime / 1000.0)
        };
        return ticker;
    });
}

/**
 * Update tickers using allPrices since last price returned by ticker24hr does not match the real last price
 *
 * @param {object} list dictionary of tickers
 * @return {Promise}
 */
async _finalizeTickers(list)
{
    let self = this;
    // not needed anymore
    return list;
    return this._limiterGlobal.schedule(async function(){
        let data;
        try
        {
            data = await self._restClient.tickerPrice();
        }
        catch (e)
        {
            if (self._isBinanceError(e))
            {
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
            }
            throw e;
        }
        _.forEach(data, (obj) => {
            let pair = self._toCustomPair(obj.symbol);
            if (undefined === list[pair])
            {
                return;
            }
            list[pair].last = parseFloat(obj.price);
        });
        return list;
    });
}

/**
 * Used to ensure we use a supported limit
 *
 * @param {integer} limit requested order book limit
 * @return {integer} supported limit (>= requested limit)
 */
_fixOrderBookLimit(limit)
{
    if (-1 != supportedOrderBooksLimits.indexOf(limit))
    {
        return limit;
    }
    for (var i = 0; i < supportedOrderBooksLimits.length; ++i)
    {
        if (supportedOrderBooksLimits[i] >= limit)
        {
            return supportedOrderBooksLimits[i];
        }
    }
}

/**
 * Retrieve order book for a single pair

 * @param {string} pair pair to retrieve order book for
 * @param {integer} opt.limit maximum number of entries (for both ask & bids)
 * @param {object} opt.custom.includeLastUpdateId whether or not 'lastUpdateId' field should be present in result (optional, default = false)
 * @return {Promise}
 */
 /*
 Raw output example for https://api.binance.com/api/v1/depth

 {
     "lastUpdateId":43003296,
     "bids":[
         [
             "51.15100000",
             "0.03900000",
             [

             ]
         ],
         [
             "51.12000000",
             "1.00000000",
             [

             ]
         ]
     ],
     "asks":[
         [
             "51.20300000",
             "39.39200000",
             [

             ]
         ],
         [
             "51.21000000",
             "29.77300000",
             [

             ]
         ]
     ]
 }

 */
async _getOrderBook(pair, opt)
{
    if (undefined == opt.limit)
    {
        opt.limit = ORDER_BOOK_DEFAULT_LIMIT;
    }
    if (undefined === opt.custom.includeLastUpdateId)
    {
        opt.custom.includeLastUpdateId = false;
    }
    let symbol = this._toExchangePair(pair);
    let self = this;
    let limiter = this._limiterGlobal;
    if (undefined !== orderBooksWeights[opt.limit])
    {
        switch (orderBooksWeights[opt.limit])
        {
            case 5:
                limiter = this._limiterWeight5;
                break;
            case 10:
                limiter = this._limiterWeight10;
                break;
            default:
                limiter = this._limiterWeight10;
                break;
        }
    }
    return limiter.schedule(async function(){
        let data;
        try
        {
            data = await self._restClient.depth({symbol:symbol, limit:opt.limit});
        }
        catch (e)
        {
            if (self._isBinanceError(e))
            {
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
            }
            throw e;
        }
        let result = {
            buy:_.map(data.bids, arr => {
                return {
                    rate:parseFloat(arr[0]),
                    quantity:parseFloat(arr[1])
                }
            }),
            sell:_.map(data.asks, arr => {
                return {
                    rate:parseFloat(arr[0]),
                    quantity:parseFloat(arr[1])
                }
            })
        }
        if (opt.custom.includeLastUpdateId)
        {
            result.lastUpdateId = data.lastUpdateId;
        }
        return result;
    });
}

/**
 * Retrieve last trades
 *
 * @param {string} pair pair to retrieve order book for
 * @param {integer} opt.limit maximum number of entries
 * @param {object} opt.custom (optional)
 * @return {Promise}
 */
 /*
 Raw output example for https://api.binance.com/api/v1/trades

 [
     {
         "id":7215767,
         "price":"50.83400000",
         "qty":"0.59900000",
         "time":1523270827905,
         "isBuyerMaker":false,
         "isBestMatch":true
     },
     {
         "id":7215768,
         "price":"50.90500000",
         "qty":"0.44600000",
         "time":1523270827905,
         "isBuyerMaker":false,
         "isBestMatch":true
     }
 ]
 */
async _getTrades(pair, opt)
{
    if (undefined === opt.limit)
    {
        opt.limit = TRADES_DEFAULT_LIMIT;
    }
    let symbol = this._toExchangePair(pair);
    let self = this;
    return this._limiterGlobal.schedule(async function(){
        let data;
        try
        {
            data = await self._restClient.aggTrades({symbol:symbol,limit:opt.limit});
        }
        catch (e)
        {
            if (self._isBinanceError(e))
            {
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
            }
            throw e;
        }
        let list = [];
        _.forEach(data, (entry) => {
            let quantity = parseFloat(entry.q);
            let rate = parseFloat(entry.p);
            let price = parseFloat(new Big(quantity).times(rate).toFixed(8));
            let orderType = 'sell';
            // seems to be reversed and when 'm' is true, entry is displayed in RED on Binance website
            if (false === entry.m)
            {
                orderType = 'buy';
            }
            list.unshift({
                id:entry.a,
                quantity:quantity,
                rate:rate,
                price:price,
                orderType:orderType,
                timestamp:parseFloat(entry.T / 1000.0)
            })
        });
        return list;
    });
}

/**
 * Returns charts data
 *
 * @param {string} pair pair to retrieve chart data for
 * @param {string} interval charts interval
 * @param {integer} fromTimestamp unix timestamp in seconds
 * @param {integer} toTimestamp unix timestamp in seconds
 * @return {Promise}
 */
 /*
 Raw output example for https://api.binance.com/api/v1/klines

 [
     [
         1522971600000,
         "47.15100000",
         "47.28300000",
         "47.09700000",
         "47.10000000",
         "327.06600000",
         1522971899999,
         "15426.14975400",
         49,
         "238.06000000",
         "11224.65511800",
         "0"
     ],
     [
         1522971900000,
         "47.10100000",
         "47.20000000",
         "47.09600000",
         "47.20000000",
         "118.97300000",
         1522972199999,
         "5609.20634500",
         31,
         "112.53700000",
         "5306.05059700",
         "0"
     ]
 ]
 */
async _getKlines(pair, interval, fromTimestamp, toTimestamp)
{
    let symbol = this._toExchangePair(pair);
    let opt = {symbol:symbol, interval:interval, startTime:fromTimestamp * 1000, endTime:toTimestamp * 1000}
    let self = this;
    return this._limiterGlobal.schedule(async function(){
        let data;
        try
        {
            data = await self._restClient.klines(opt);
        }
        catch (e)
        {
            if (self._isBinanceError(e))
            {
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
            }
            throw e;
        }
        let list = [];
        _.forEach(data, (entry) => {
            list.push({
                timestamp:parseInt(entry[0] / 1000.0),
                open:parseFloat(entry[1]),
                high:parseFloat(entry[2]),
                low:parseFloat(entry[3]),
                close:parseFloat(entry[4]),
                volume:parseFloat(entry[5])
            });
        });
        return list;
    });
}

/**
 * Retrieve open orders for a single pair

 * @param {string} pair pair to retrieve open orders for
 * @return {Promise}
 */
 /*
 Raw output example for https://api.binance.com/api/v3/openOrders

 [
     {
         "symbol":"LTCBTC",
         "orderId":1,
         "clientOrderId":"myOrder1",
         "price":"0.1",
         "origQty":"1.0",
         "executedQty":"0.0",
         "status":"NEW",
         "timeInForce":"GTC",
         "type":"LIMIT",
         "side":"BUY",
         "stopPrice":"0.0",
         "icebergQty":"0.0",
         "time":1499827319559,
         "isWorking":true
     }
 ]
 */
async _getOpenOrdersForPair(pair)
{
    let symbol = this._toExchangePair(pair);
    let self = this;
    return this._limiterGlobal.schedule(async function(){
        let data;
        try
        {
            data = await self._restClient.openOrders({symbol:symbol});
        }
        catch (e)
        {
            if (self._isBinanceError(e))
            {
                if (self._isInvalidAuthError(e))
                {
                    throw new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e);
                }
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
            }
            throw e;
        }
        let list = {};
        _.forEach(data, (entry) =>  {
            // we only support LIMIT orders
            if ('LIMIT' != entry.type)
            {
                return;
            }
            let orderType;
            switch (entry.side)
            {
                case 'BUY':
                    orderType = 'buy';
                    break;
                case 'SELL':
                    orderType = 'sell';
                    break;
                default:
                    return;
            }
            let order = {
                pair:pair,
                orderType:orderType,
                orderNumber:entry.clientOrderId,
                targetRate:parseFloat(entry.price),
                quantity:parseFloat(entry.origQty),
                openTimestamp:parseFloat(entry.time / 1000.0)
            }
            order.targetPrice = parseFloat(new Big(order.targetRate).times(order.quantity).toFixed(8));
            order.remainingQuantity = order.quantity - parseFloat(entry.executedQty);
            list[order.orderNumber] = order;
        });
        return list;
    });
}

/**
 * Retrieve all orders for a single symbol (ie: exchange format, not custom format!) (internal use)

 * @param {string} symbol symbol to retrieve closed orders for
 * @param {boolean} opt.completeHistory whether or not all orders should be retrieved (might not be supported on all exchanges)
 * @param {object} opt.orderStates dictionary of expected order states {'state1':true,'state2':true} (ex: {'NEW':true,'PARTIALLY_FILLED':true}) (optional)
 * @return {Promise} Promise which will resolve to an array such as below (raw data returned by exchange)
 */
/*
Raw output example for https://api.binance.com/api/v3/allOrders

[
    {
        "symbol":"LTCBTC",
        "orderId":1,
        "clientOrderId":"myOrder1",
        "price":"0.1",
        "origQty":"1.0",
        "executedQty":"0.0",
        "status":"NEW",
        "timeInForce":"GTC",
        "type":"LIMIT",
        "side":"BUY",
        "stopPrice":"0.0",
        "icebergQty":"0.0",
        "time":1499827319559,
        "isWorking":true
    }
]
*/
async _getOrdersForSymbol(symbol, opt)
{
    let self = this;
    let list = [];
    let orderId = 1;
    let limit = ALL_ORDERS_LIMIT_PER_ITER;
    while (true)
    {
        let data;
        try
        {
            data = await this._limiterWeight5.schedule(async function(){
                let params = {symbol:symbol,limit:limit};
                if (opt.completeHistory)
                {
                    params.orderId = orderId;
                }
                // will return the oldest order first
                return await self._restClient.allOrders(params);
            });
        }
        catch (e)
        {
            if (self._isBinanceError(e))
            {
                if (self._isInvalidAuthError(e))
                {
                    throw new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e);
                }
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
            }
            throw e;
        }
        let pair = self._toCustomPair(symbol);
        _.forEach(data, (entry) => {
            // we only support LIMIT orders
            if ('LIMIT' != entry.type)
            {
                return;
            }
            let orderState = 'closed';
            switch (entry.status)
            {
                case 'NEW':
                case 'PARTIALLY_FILLED':
                    orderState = 'open';
                    break;
                case 'CANCELED':
                    if (0 == entry.executedQty)
                    {
                        orderState = 'cancelled';
                        break;
                    }
            }
            // update cached orders
            self._cacheOrder(entry.clientOrderId, pair, orderState);

            // not the status we are looking for
            if (undefined !== opt.orderStates && undefined === opt.orderStates[entry.status])
            {
                return;
            }
            list.unshift(entry);
        });
        // we don't need more orders or we don't have more
        if (!opt.completeHistory || data.length < limit)
        {
            break;
        }
        // most recent is last one
        orderId = data[data.length - 1].orderId + 1;
    }
    return list;
}

/**
 * Retrieve closed orders for a single pair

 * @param {string} pair pair to retrieve closed orders for
 * @param {boolean} completeHistory whether or not all orders should be retrieved (might not be supported on all exchanges)
 * @return {Promise}
 */
async _getClosedOrdersForPair(pair, completeHistory)
{
    let symbol = this._toExchangePair(pair);
    let data;
    let _opt = {completeHistory:completeHistory, orderStates:{'FILLED':true,'CANCELED':true}};
    try
    {
        data = await this._getOrdersForSymbol(symbol, _opt);
    }
    catch (e)
    {
        if (this._isBinanceError(e))
        {
            if (this._isInvalidAuthError(e))
            {
                throw new Errors.ExchangeError.Forbidden.InvalidAuthentication(this.getId(), e);
            }
            throw new Errors.ExchangeError.InvalidRequest.UnknownError(this.getId(), e);
        }
        throw e;
    }
    let list = {};
    // list of orders for which we need to retrieve closedTimestamps & fees
    let ordersToFinalize = {};
    _.forEach(data, (entry) => {
        let orderType;
        switch (entry.side)
        {
            case 'BUY':
                orderType = 'buy';
                break;
            case 'SELL':
                orderType = 'sell';
                break;
            default:
                return;
        }
        let order = {
            pair:pair,
            orderType:orderType,
            orderNumber:entry.clientOrderId,
            actualRate:null,
            actualPrice:0,
            quantity:parseFloat(entry.executedQty),
            openTimestamp:parseFloat(entry.time / 1000.0),
            closedTimestamp:null,
            fees:null,
            finalRate:null,
            finalPrice:null
        }
        list[order.orderNumber] = order;
        // keep this order in the list we need to finalize (ie: retrieve fees and closedTimestamp)
        if (0 != order.quantity)
        {
            order.actualRate = parseFloat(entry.price);
            order.actualPrice = parseFloat(new Big(order.actualRate).times(order.quantity).toFixed(8));
            ordersToFinalize[entry.orderId] = order.orderNumber;
        }
    });
    if (!_.isEmpty(ordersToFinalize))
    {
        let closedTimestampsAndFees;
        try
        {
            closedTimestampsAndFees = await this._getClosedTimestampsAndFeesForOrders(ordersToFinalize, symbol);
        }
        catch (e)
        {
            if (this._isBinanceError(e))
            {
                if (this._isInvalidAuthError(e))
                {
                    throw new Errors.ExchangeError.Forbidden.InvalidAuthentication(this.getId(), e);
                }
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(this.getId(), e);
            }
            throw e;
        }
        _.forEach(closedTimestampsAndFees, (e, orderNumber) => {
            list[orderNumber].fees = {
                amount:e.fees.amount,
                currency:e.fees.currency
            }
            list[orderNumber].closedTimestamp = e.closedTimestamp;
            let splittedPair = list[orderNumber].pair.split('-');
            // only compute order.finalPrice & order.finalRate if fees.currency != from baseCurrency (otherwise use order.actualPrice & order.actualRate)
            if (splittedPair[0] != e.fees.currency)
            {
                list[orderNumber].finalPrice = list[orderNumber].actualPrice;
                list[orderNumber].finalRate = list[orderNumber].actualRate;
                return;
            }
            let finalPrice;
            if ('buy' == list[orderNumber].orderType)
            {
                finalPrice =  new Big(list[orderNumber].actualPrice).plus(e.fees.amount);
            }
            else
            {
                finalPrice =  new Big(list[orderNumber].actualPrice).minus(e.fees.amount);
            }
            list[orderNumber].finalPrice = parseFloat(finalPrice.toFixed(8));
            list[orderNumber].finalRate = parseFloat(finalPrice.div(list[orderNumber].quantity).toFixed(8));
        });
    }
    return list;
}

/**
 * Used to retrieve the pair for a given order (will be called in case _getOrder cannot be called without a pair)
 *
 * @param {string} orderNumber orderNumber
 * @return {Promise}
 */
async _getOrderPair(orderNumber)
{
    let self = this;
    let cachedOrder = this._getCachedOrder(orderNumber);
    // we already know the pair for this order
    if (null !== cachedOrder)
    {
        return cachedOrder.pair;
    }
    let pairs = await this.getPairsSymbols(true);
    // we don't have any cached pair
    if (0 == pairs.length)
    {
        return null;
    }
    let arr = [];
    _.forEach(pairs, (pair) => {
        let symbol = this._toExchangePair(pair);
        let p = this._getOrdersForSymbol(symbol, {completeHistory:true});
        arr.push({promise:p, context:{exchange:this._id,api:'_getOrdersForSymbol',symbol:symbol}});
    });
    let pair = null;
    let data = await PromiseHelper.all(arr);
    _.forEach(data, (entry) => {
        // could not retrieve orders for a given symbol
        if (!entry.success)
        {
            return;
        }
        _.forEach(entry.value, (order) => {
            pair = this._toCustomPair(order.symbol);
            // we're not interested in this order
            if (orderNumber != order.clientOrderId)
            {
                return;
            }
            return false;
        });
    });
    return pair;
}

/**
 * Find closed timestamp & fees for a given order id
 *
 * @param {integer} orders {orderId:orderNumber} object containing identifier of the orders to retrieve information for (orderId)
 * @param {string} symbol
 * @return {Promise} which will resolve to an object such as below
 */
 /*
 Raw output example for https://api.binance.com/api/v3/myTrades

 [
     {
         "id":28457,
         "orderId":100234,
         "price":"4.00000100",
         "qty":"12.00000000",
         "commission":"10.10000000",
         "commissionAsset":"BNB",
         "time":1499865549590,
         "isBuyer":true,
         "isMaker":false,
         "isBestMatch":true
     }
 ]

Output example

{
    "024TKrQPmq8qth7tT3WxIX":{
        "closedTimestamp":1505030250.594,
        "fees":{
            "amount":0.24425807,
            "currency":"BNB"
        }
    },
    "6z8II77B0nQz2bjn6Yq8ha":{
        "closedTimestamp":1505199222.089,
        "fees":{
            "amount":0.21240182,
            "currency":"BNB"
        }
    }
}

*/
async _getClosedTimestampsAndFeesForOrders(orders, symbol)
{
    let tradeId = 1;
    let limit = OWN_TRADES_LIMIT_PER_ITER;
    let list = {};
    let self = this;
    while (true)
    {
        let data;
        try
        {
            data = await this._limiterWeight5.schedule(async function(){
                let params = {symbol:symbol,limit:limit,fromId:tradeId};
                // will return the oldest trade first
                return await self._restClient.myTrades(params);
            });
        }
        catch (e)
        {
            if (this._isBinanceError(e))
            {
                if (this._isInvalidAuthError(e))
                {
                    throw new Errors.ExchangeError.Forbidden.InvalidAuthentication(this.getId(), e);
                }
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(this.getId(), e);
            }
            throw e;
        }
        _.forEach(data, (entry) => {
            // we're not interested in this order
            if (undefined === orders[entry.orderId])
            {
                return;
            }
            let orderNumber = orders[entry.orderId];
            // initialize order
            if (undefined === list[orderNumber])
            {
                list[orderNumber] = {
                    closedTimestamp:null,
                    fees:{
                        amount:new Big(0),
                        currency:entry.commissionAsset
                    }
                };
            }
            if (entry.time < list[orderNumber].closedTimestamp)
            {
                return;
            }
            list[orderNumber].closedTimestamp = entry.time;
            list[orderNumber].fees.amount = list[orderNumber].fees.amount.plus(entry.commission);
        });
        // we don't have more
        if (data.length < limit)
        {
            break;
        }
        // most recent is last one
        tradeId = data[data.length - 1].id + 1;
    }
    _.forEach(list, (e) => {
        if (0 == e.closedTimestamp)
        {
            e.closedTimestamp = null;
        }
        else
        {
            e.closedTimestamp = parseFloat(e.closedTimestamp / 1000.0);
        }
        e.fees.amount = parseFloat(e.fees.amount.toFixed(8))
    });
    return list;
}

/**
 * Retrieves a single order (open or closed)
 *
 * @param {string} orderNumber
 * @param {string} pair pair (ex: USDT-NEO) (will always be defined)
 * @return {Promise}
 */
/*
 Raw output for https://api.binance.com/api/v3/order

 {
     "symbol":"LTCBTC",
     "orderId":1,
     "clientOrderId":"myOrder1",
     "price":"0.1",
     "origQty":"1.0",
     "executedQty":"0.0",
     "status":"NEW",
     "timeInForce":"GTC",
     "type":"LIMIT",
     "side":"BUY",
     "stopPrice":"0.0",
     "icebergQty":"0.0",
     "time":1499827319559,
     "isWorking":true
 }

 */
async _getOrder(orderNumber, pair)
{
    let self = this;
    let symbol = this._toExchangePair(pair);
    return this._limiterGlobal.schedule(async function(){
        let data;
        try
        {
            data = await self._restClient.queryOrder({origClientOrderId:orderNumber, symbol:symbol});
        }
        catch (e)
        {
            if (self._isBinanceError(e))
            {
                // NO_SUCH_ORDER
                if (-2013 == e.code)
                {
                    throw new Errors.ExchangeError.InvalidRequest.OrderError.OrderNotFound(self.getId(), orderNumber, e);
                }
                if (self._isInvalidAuthError(e))
                {
                    throw new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e);
                }
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
            }
            throw e;
        }
        // we only support LIMIT order
        if ('LIMIT' != data.type)
        {
            throw new Errors.ExchangeError.InvalidRequest.OrderError.OrderNotFound(self.getId(), orderNumber);
        }
        let orderState;
        switch (data.status)
        {
            case 'NEW':
            case 'PARTIALLY_FILLED':
                orderState = 'open';
                break;
            case 'FILLED':
                orderState = 'closed';
                break;
            case 'CANCELED':
                orderState = 'closed';
                break;
            default:
                throw new Errors.ExchangeError.InvalidRequest.OrderError.OrderNotFound(self.getId(), orderNumber);
        }
        let orderType;
        switch (data.side)
        {
            case 'BUY':
                orderType = 'buy';
                break;
            case 'SELL':
                orderType = 'sell';
                break;
            default:
                logger.warn(`Unknown order type '${data.side}' for '${self.getId()}' order '${orderNumber}'`);
                throw new Errors.GatewayError.InternalError();
        }
        let order = {
            pair:pair,
            orderType:orderType,
            orderNumber:orderNumber,
            openTimestamp:parseFloat(data.time / 1000.0),
            quantity:parseFloat(data.origQty)
        }
        if ('open' == orderState)
        {
            order.targetRate = parseFloat(data.price);
            order.remainingQuantity = order.quantity - parseFloat(data.executedQty);
            order.targetPrice = parseFloat(new Big(order.targetRate).times(order.quantity).toFixed(8));
        }
        else
        {
            order.quantity = parseFloat(data.executedQty);
            order.actualRate = null;
            order.actualPrice = 0;
            order.closedTimestamp = null;
            order.fees = null;
            order.finalRate = null;
            order.finalPrice = null;
            let closedTimestampsAndFees;
            // only if order as been filled
            if (0 != order.quantity)
            {
                order.actualRate = parseFloat(data.price);
                order.actualPrice = parseFloat(new Big(order.actualRate).times(order.quantity).toFixed(8));
                try
                {
                    let orders = {};
                    orders[data.orderId] = orderNumber;
                    closedTimestampsAndFees = await self._getClosedTimestampsAndFeesForOrders(orders, data.symbol);
                }
                catch (e)
                {
                    if (self._isBinanceError(e))
                    {
                        if (self._isInvalidAuthError(e))
                        {
                            throw new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e);
                        }
                        throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
                    }
                    throw e;
                }
                if (undefined != closedTimestampsAndFees[orderNumber])
                {
                    order.fees = {
                        amount:closedTimestampsAndFees[orderNumber].fees.amount,
                        currency:closedTimestampsAndFees[orderNumber].fees.currency
                    }
                    order.closedTimestamp = closedTimestampsAndFees[orderNumber].closedTimestamp;
                    let splittedPair = order.pair.split('-');
                    // only compute order.finalPrice & order.finalRate if fees.currency != from order.baseCurrency (otherwise use order.actualPrice & order.actualRate)
                    if (splittedPair[0] != order.fees.currency)
                    {
                        order.finalPrice = order.actualPrice;
                        order.finalRate = order.actualRate;
                    }
                    else
                    {
                        let finalPrice;
                        if ('buy' == order.orderType)
                        {
                            finalPrice =  actualPrice.plus(order.fees.amount);
                        }
                        else
                        {
                            finalPrice =  actualPrice.minus(order.fees.amount);
                        }
                        order.finalPrice = parseFloat(finalPrice.toFixed(8));
                        order.finalRate = parseFloat(finalPrice.div(order.quantity).toFixed(8));
                    }
                }
            }
        }
        return order;
    });
}

/**
 * Creates a new order
 *
 * @param {string} orderType (buy|sell)
 * @param {string} pair pair to buy/sell
 * @param {float} targetRate expected buy/sell price
 * @param {float} quantity quantity to buy/sell
 * @return {Promise} Promise which will resolve to the number of the new order
 */
/*
Raw output for https://api.binance.com/api/v3/order

{
    "symbol":"BTCUSDT",
    "orderId":28,
    "clientOrderId":"6gCrw2kRUAF9CvJDGP16IP",
    "transactTime":1507725176595,
    "price":"0.00000000",
    "origQty":"10.00000000",
    "executedQty":"10.00000000",
    "status":"FILLED",
    "timeInForce":"GTC",
    "type":"MARKET",
    "side":"SELL"
}
*/
async _createOrder(orderType, pair, targetRate, quantity)
{
    let self = this;
    return this._limiterGlobal.schedule(async function(){
        // convert pair to remote format
        let symbol = self._toExchangePair(pair);
        let timestamp = new Date().getTime();
        let query = {
            symbol:symbol,
            side:'BUY',
            type:'LIMIT',
            quantity:quantity.toFixed(8),
            price:targetRate.toFixed(8),
            timeInForce:'GTC',
            timestamp:timestamp
        };
        if ('sell' == orderType)
        {
            query.side = 'SELL';
        }
        let data;
        try
        {
            data = await self._restClient.newOrder(query);
        }
        catch (e)
        {
            if (self._isBinanceError(e))
            {
                // NEW_ORDER_REJECTED
                if (-2010 == e.code)
                {
                    if (/insufficient balance/.test(e.msg))
                    {
                        throw new Errors.ExchangeError.InvalidRequest.OrderError.InvalidOrderDefinition.InsufficientFunds(self.getId(), pair, targetRate, quantity, e);
                    }
                }
                if (self._isInvalidAuthError(e))
                {
                    throw new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e);
                }
                if (self._isInvalidRequestError(e))
                {
                    if (/LOT_SIZE/.test(e.msg))
                    {
                        throw new Errors.ExchangeError.InvalidRequest.OrderError.InvalidOrderDefinition.InvalidQuantity(self.getId(), pair, quantity, e);
                    }
                    else if (/PRICE_FILTER/.test(e.msg))
                    {
                        throw new Errors.ExchangeError.InvalidRequest.OrderError.InvalidOrderDefinition.InvalidRate(self.getId(), pair, targetRate, e);
                    }
                    else if (/MIN_NOTIONAL/.test(e.msg))
                    {
                        throw new Errors.ExchangeError.InvalidRequest.OrderError.InvalidOrderDefinition.InvalidPrice(self.getId(), pair, targetRate, quantity, e);
                    }
                }
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
            }
            throw e;
        }
        // update cached orders
        self._cacheOrder(data.clientOrderId, pair, 'open');
        // only return order number
        return data.clientOrderId;
    });
}

/**
 * Cancels an existing order
 *
 * @param {string} orderNumber number of the order to cancel
 * @param {string} pair pair (ex: USDT-NEO) (will always be defined)
 * @return {Promise} Promise which will resolve to true in case of success
 */
/*
Raw output for https://api.binance.com/api/v3/order

{
    "symbol":"LTCBTC",
    "origClientOrderId":"myOrder1",
    "orderId":1,
    "clientOrderId":"cancelMyOrder1"
}
*/
async _cancelOrder(orderNumber, pair)
{
    let self = this;
    let symbol = self._toExchangePair(pair);
    return this._limiterGlobal.schedule(async function(){
        // convert pair to remote format
        let query = {
            symbol:symbol,
            origClientOrderId:orderNumber
        };
        let data;
        try
        {
            data = await self._restClient.cancelOrder(query);
            return true;
        }
        catch (e)
        {
            if (self._isBinanceError(e))
            {
                // CANCEL_REJECTED
                if (-2011 == e.code)
                {
                    // try to retrieve order to see if it's closed
                    let order;
                    try
                    {
                        order = await self._getOrder(orderNumber, pair);
                    }
                    catch (_e)
                    {
                        throw new Errors.ExchangeError.InvalidRequest.OrderError.OrderNotFound(self.getId(), orderNumber, e);
                    }
                    // order is closed
                    if (undefined !== order.closedTimestamp)
                    {
                        throw new Errors.ExchangeError.InvalidRequest.OrderError.OrderNotOpen(self.getId(), orderNumber, e);
                    }
                }
                if (self._isInvalidAuthError(e))
                {
                    throw new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e);
                }
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
            }
            throw e;
        }
    });
}

/**
 * Return balances for all currencies (currencies with balance = 0 should be filtered out)
 *
 * @return {Promise}
 */
/*
Raw output for https://api.binance.com/api/v3/account

{
    "makerCommission":15,
    "takerCommission":15,
    "buyerCommission":0,
    "sellerCommission":0,
    "canTrade":true,
    "canWithdraw":true,
    "canDeposit":true,
    "updateTime":123456789,
    "balances":[
        {
            "asset":"BTC",
            "free":"4723846.89208129",
            "locked":"0.00000000"
        },
        {
            "asset":"LTC",
            "free":"4763368.68006011",
            "locked":"0.00000000"
        }
    ]
}
*/
async _getBalances()
{
    let self = this;
    return this._limiterWeight5.schedule(async function(){
        let data;
        try
        {
            data = await self._restClient.account();
        }
        catch (e)
        {
            if (self._isBinanceError(e))
            {
                if (self._isInvalidAuthError(e))
                {
                    throw new Errors.ExchangeError.Forbidden.InvalidAuthentication(self.getId(), e);
                }
                throw new Errors.ExchangeError.InvalidRequest.UnknownError(self.getId(), e);
            }
            throw e;
        }
        let list = {};
        _.forEach(data.balances, (value) => {
            let available = parseFloat(value.free);
            let onOrders = parseFloat(value.locked);
            let total = available + onOrders;
            // ignore currency with 0 balance
            if (0 == total)
            {
                return;
            }
            let b = {
                currency:value.asset,
                total:total,
                available:available,
                onOrders:onOrders
            }
            list[value.asset] = b;
        });
        return list;
    });
}

}

module.exports = Exchange;
